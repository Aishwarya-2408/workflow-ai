import subprocess\nimport os\nimport sys\nimport threading\nimport io\nimport site\nimport logging\nimport re # For critical error patterns\nfrom typing import List, Dict, Any\n\nclass CodeExecutionModule:\n    def __init__(self, logger, timeout_seconds: int = 60):\n        self.logger = logger.get_logger() if hasattr(logger, 'get_logger') else logger\n        self.timeout_seconds = timeout_seconds\n        # Define critical error patterns that should halt retries\n        self.critical_error_patterns = [\n            re.compile(r"ModuleNotFoundError"),\n            re.compile(r"FileNotFoundError"),\n            re.compile(r"Permission denied"),\n            re.compile(r"SyntaxError"), # Unrecoverable syntax errors\n            re.compile(r"IndentationError"), # Unrecoverable indentation errors\n            re.compile(r"AttributeError: module \'.*?\' has no attribute \'.*?\'"),\n            re.compile(r"TypeError: \'NoneType\' object is not callable"),\n            re.compile(r"BrokenPipeError")\n        ]\n\n    def _install_packages(self, packages: List[str]) -        if not packages:\n            return True\n        self.logger.info(f"Attempting to install required packages: {', '.join(packages)}")\n        try:\n            # Ensure pip is run with the same Python interpreter\n            result = subprocess.run(\n                [sys.executable, "-m", "pip", "install", "--upgrade", "--no-input"] + packages,\n                capture_output=True,\n                text=True,\n                check=True,\n                timeout=300 # Longer timeout for package installation\n            )\n            self.logger.info(f"pip install stdout:{chr(10)}{result.stdout}")\n            if result.stderr:\n                self.logger.warning(f"pip install stderr:{chr(10)}{result.stderr}")\n            self.logger.info(f"Successfully installed packages: {', '.join(packages)}")\n            return True\n        except subprocess.CalledProcessError as e:\n            self.logger.error(f"Failed to install packages: {e}", exc_info=True)\n            self.logger.error(f"pip install stdout:{chr(10)}{e.stdout}")\n            self.logger.error(f"pip install stderr:{chr(10)}{e.stderr}")\n            return False\n        except subprocess.TimeoutExpired:\n            self.logger.error(f"Package installation timed out after 300 seconds for packages: {', '.join(packages)}")\n            return False\n        except Exception as e:\n            self.logger.error(f"An unexpected error occurred during package installation: {e}", exc_info=True)\n            return False\n\n    def execute_code(self, code_string: str, required_packages: List[str] = None, output_dir: str = None) -, Any]:\n        temp_script_path = "generated_script.py"\n        output_result = {\n            "success": False,\n            "stdout": "",\n            "stderr": "",\n            "exit_code": None,\n            "error": None\n        }\n\n        # Handle required packages\n        if required_packages:\n            if not self._install_packages(required_packages):\n                output_result["error"] = "Failed to install required packages."\n                output_result["stderr"] = "Failed to install required packages for generated code."\n                return output_result\n\n        # Save code to a temporary file\n        try:\n            with open(temp_script_path, "w", encoding="utf-8") as f:\n                f.write(code_string)\n        except Exception as e:\n            self.logger.error(f"Failed to write generated code to temp file: {e}", exc_info=True)\n            output_result["error"] = f"Failed to write generated code: {e}"\n            return output_result\n\n        # Prepare environment for execution\n        env = os.environ.copy()\n        # Ensure that the current directory is in PYTHONPATH for local imports\n        current_dir = os.path.abspath(os.path.dirname(temp_script_path))\n        if 'PYTHONPATH' in env:\n            env['PYTHONPATH'] = f"{current_dir}{os.pathsep}{env['PYTHONPATH']}"\n        else:\n            env['PYTHONPATH'] = current_dir\n\n        # Add the output_dir to the environment if provided, so the generated code can use it\n        if output_dir:\n            env['AGENT_OUTPUT_DIR'] = output_dir\n            self.logger.info(f"Set AGENT_OUTPUT_DIR environment variable to: {output_dir}")\n\n        # Execute the code using subprocess\n        try:\n            # sys.executable ensures the correct Python interpreter is used\n            process = subprocess.run(\n                [sys.executable, temp_script_path],\n                capture_output=True,\n                text=True,\n                check=False, # Do not raise CalledProcessError for non-zero exit codes\n                timeout=self.timeout_seconds,\n                env=env # Pass the modified environment variables\n            )\n\n            output_result["stdout"] = process.stdout\n            output_result["stderr"] = process.stderr\n            output_result["exit_code"] = process.returncode\n\n            if process.returncode == 0:\n                output_result["success"] = True\n                self.logger.info("Code executed successfully.")\n            else:\n                output_result["error"] = f"Code execution failed with exit code {process.returncode}."\n                self.logger.error(f"Code execution failed. Exit code: {process.returncode}")\n                self.logger.error(f"STDOUT:{chr(10)}{process.stdout}")\n                self.logger.error(f"STDERR:{chr(10)}{process.stderr}")\n\n        except subprocess.TimeoutExpired:\n            self.logger.error(f"Code execution timed out after {self.timeout_seconds} seconds.")\n            output_result["error"] = f"Execution timed out after {self.timeout_seconds} seconds."\n            output_result["stderr"] = "Execution timed out."\n        except Exception as e:\n            self.logger.error(f"An unexpected error occurred during code execution: {e}", exc_info=True)\n            output_result["error"] = f"Unexpected execution error: {e}"\n            output_result["stderr"] = f"Unexpected execution error: {e}"\n        finally:\n            # Clean up the temporary script file\n            if os.path.exists(temp_script_path):\n                os.remove(temp_script_path)\n        return output_result" > Backend/agent_core/code_execution_module.py
